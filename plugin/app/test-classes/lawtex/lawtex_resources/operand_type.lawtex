/* Operand Test: Testando todos os casos de operand type e operand sobre um período */

*period[PER_Teste] {
	name = "Período teste"
	description = "Período para teste de operandos"
	tags {
		"Teste 1", "Operand", "OperandType"
	}
	declarations {
		+<varListAlias01> : List[AliasList] {  /* LOCAL INCOMPLETE */
			name = "..."
			request = "..."
			atomic = true
			help = "..."
			tip = "..."
		},
		-<varListAlias02> : List("opt1","opt2") { /* LOCAL COMPLETE */
			name = "..."
			request = "..."
			atomic = false
			help = "..."
			tip = "..."
		},
		+<varListAlias03> : List({"opt1"},{"opt2"}),  	/* LOCAL COMPLETE */
		+<variableAlias04> : String {  					/* PRIM LOCAL */
			name = "..."
			request = "..."
			default = "..."
			help = "..."
			tip = "..."
		},
		-<variableAlias05> : Boolean { 					/* PRIM LOCAL */
			request = "..."
		},
		&<variableAlias06> : Integer, 					/* PRIM LOCAL */
		&<variableAlias07> : externs Integer, 			/* PRIM EXT */
		+<objectAlias08> : *StructAlias { 				/* LOCAL INCOMPLETE */
			name = "..."
			request = "..."
			help = "..."
		},
		-<objectAlias09> : *StructAlias { 				/* LOCAL INCOMPLETE */
			request = "..."
		},
		&<objectAlias10> : *StructAlias,					/* LOCAL INCOMPLETE */
		&<objectAlias11> : externs *StructAlias,			/* LOCAL EXT -- devia dar erro */
		&<objectAlias12> : *StructAlias where ([fieldAlias] = "12:54",[fieldAlias].mandatory = "+"),
														/* LOCAL EXT -- devia dar erro */
		+#constantAlias13# : Real { 					/* PRIM LOCAL */
			name = "..."
			value = "..."
			help = "..."
		},
		-#constantAlias14# : Date { 					/* PRIM LOCAL */
			value = "..."
		},
		&#constantAlias15# : String, 					/* PRIM LOCAL */
		&#constantAlias16# : externs String,			/* PRIM EXT */
		+|vectorAlias17| : Vector[Integer] { 			/* VECT LOCAL */
			name = "..."
			request = "..."
			default = 1
			help = "..."
		},
		-|vectorAlias18| : Vector[Integer] {},			/* VECT LOCAL */
		&|vectorAlias19| : Vector[Integer],				/* VECT LOCAL */
		+|vectorAlias20| : Vector[*StructAlias] { 		/* VECT LOCAL */
			name = "..."
			request = "..."
			help = "..."
		},
		-|vectorAlias21| : Vector[*StructAlias] {},		/* VECT LOCAL */
		&|vectorAlias22| : Vector[*StructAlias],			/* VECT LOCAL */
		+|vectorAlias23| : Vector[List[AliasList]] { 	/* VECT-LIST LOCAL INCOMPLETE */
			name = "..."
			atomic = false
			request = "..."
			default = {"Option1a","Option2a"}
			help = "..."
		},
		+|vectorAlias24| : Vector[List("a","b")] { 		/* VECT LOCAL COMPLETE */
			name = "..."
			atomic = true
			request = "..."
			default = "a"
			help = "..."
		},
		+|vectorAlias25| : Vector[List("a","b")] { 		/* VECT LOCAL COMPLETE */
			atomic = true
		},
		&#constantAlias15# : String where ("[1,121]","reverse", "\d\dsodijaosidj\r\a\@"),
		+|vectorAlias26| : Vector[List("a","b")],		/* VECT LOCAL COMPLETE */
		+|vectorAlias27| : externs Vector[Integer],		/* VECT LOCAL EXT */
		+|vectorAlias28| : externs Vector[*StructAlias],	/* VECT LOCAL EXT */
		+|vectorAlias29| : externs Vector[List[AliasList]], /* VECT-LIST LOCAL EXT */
		+|vectorAlias30| : externs Vector[String where ("\d\d\d.\d\d\d.\d\d\d-\d\d")] /* VECT-PRIM LOCAL EXT */
		/*
		&<objectAlias12> : *StructAliasOut, 			/* GLOB INCOMPLETE : sem link dá erro *
		&<varListAlias04> : externs List[String],  		/* LIST-PRIM EXT ---> Não é um tipo Struct, parece que daria erro *
		&<varListAlias05> : List[*String], 				/* LIST-PRIM INCOMPLETE devia dar erro*
		+|vectorAlias32| : externs Vector[List[Integer]], /* VECT-LIST-PRIM LOCAL EXT ---> Não é um tipo Struct, parece que daria erro*
		&<varListAlias35> : List[*AliasListOut],		/* LIST GLOB INCOMPLETE - devia dar erro *
		&<varListAlias36> : List[String], 				/* devia dar erro*/
	}
	operation {
		print {
			version = "..."
		}
	}
}

*struct[StructAlias] {
	name = "..."
	request = "..."
	help = "..."
	fields {
		-[fieldAlias] : Time {
			name = "..."
			key = false
			default = "..."
			help = "..."
		},
		if ([fieldAlias] == now()) {
			+[fieldStructAliasN] : String
		} elseif ([fieldAlias] == now() - 1) {
			+[fieldAliasY] : Time,
			if ([fieldAliasY] == now()) {
				+[fieldStructAliasY] : String
			}
		} else {
			+[fieldStructAliasT] : Date
		}
	}
}

*list[AliasList] {
	name = "..."
	fields = {"Key1", "Key2"}
	options = ({"Option1a","Option2a"}, {"Option1b","Option2b"})
	type = "String"
}
