*branch[BRC_AliasBranch] {
	name = "..."
	description = "..."
	tags {
		"...", "..."
	}
	declarations {
		&<objectAlias> : *StructName,
		&#constantAlias# : String where("CEP") {
			name = "..."
			value = "..."
			help = "..."
		}
	}
	operations {
		use period[XXX_Alias] where ( <innerObjectAlias> = <objectAlias>, <innerObjectAlias2> = <objectAlias2>/*, name = "NOME" & "ooo "& <a>*/),
		foreach(<elem> IN |vect|) {
			if (FORALL <proxy> IN |elem.outrovect| : <proxy> == "...") {
				print {
					version = "..." & "  sss" & <sss> & <elem> & "  " & <proxy>
				}
			} else {
				print {
					version ="texto simples"
				}
			}
		}
	}
}

*dependency[DEP_AliasDependency] {
	name = "..."
	description = "..."
	tags {
		"...", "..."
	}
	declarations {
		&<objectAlias11111> : *StructName,
		&<objectAlias22222> : *StructName,
		&#perobaDoCampo# : externs Date
	}
	operation {
		if ( <objectAlias>.isEmpty() ) {
			if ( <objectAlias>.isEmpty() ) {
			 	use *loop[XXX_AliasBrocado] where ( <innerObject> = <objectAlias> )
			} elseif ( <objectAlias.n> > 1 ) {
			 	use *loop[XXX_Alias] where ( <innerObject> = <objectAlias> )
			},
 			use *topic[XXX_Alias] where ( <innerObject> = <objectAlias> )
		} elseif ( <objectAlias>.mandatory == "&" ) {
			use *branch[XXX_Alias] where ( <innerObject> = <objectAlias> ),
			if ( <objectAlias1>.isEmpty() ) {
			 	use *loop[XXX_Alias1] where ( <innerObject1> = <objectAlias1> )
			} elseif ( <objectAlias2>.isEmpty() ) {
			 	use *dependency[XXX_Alias2] where ( <innerObject2> = <objectAlias2> )
			} else {
				use *period[XXX_Alias3]
			}
		} else {
			if (EXISTS <proxy> IN |vector| : <proxy> == "...") {
				print {
					[version = "..."],
					[version = "..."]
				}
			},
			use *dependency[XXX_Alias] where ( <innerObject> = <objectAlias> ),
			if ( <objectAlias>.isEmpty() ) {
			 	use *period[XXX_Alias] where ( <innerObject> = <objectAlias> )
			} else {
				use *topic[XXX_Alias] where ( <innerObject> = <objectAlias> )
			}
		}
	}
}
*struct[StructAliasCOMPLETE] {
	name = "..."
	request = "..."
	help = "..."
	fields {
		-[fieldAlias] : Real {
			name = "..."
			key = true
			default = "..."
			help = "..."
		},
		&[fieldStructAlias] : *StructName
	}
}

*struct[StructAlias] extends *AnotherStruct where ( [fieldAlias1] = "value", [fieldAlias2].mandatory = "-" ) {
	name = "..."
	request = "..."
	help = "..."
	fields {
		-[fieldAlias] : *StructName,
		&[fieldAlias] : Integer {
			name = "fieldLabel"
			key = true
			default = "..."
			help = "..."
		},
		&[fieldAlias] : Real {
			name = "..."
			key = false
			default = "..."
			help = "..."
		},
		&[fieldListAlias] : externs List[Integer],
		-[fieldListAlias] : XX extends *AnotherStruct where ( [fieldAlias1] = "value", [fieldAlias2].mandatory = "-" )
	}
}

*list[AliasList] {
	name = "..."
	fields = {"Key1", "Key2"}
	options = ("Option1", "Option2")
	type = "String"
}

*list[AliasList] {
	name = "..."
	options = ("Option1", "Option2")
	type = "String"
}

*loop[LOOP_AliasLoop] {
	name = "..."
	description = "..."
	separator = "%f1; %s2; %p2; e %l2."
	tags {
		"...", "..."
	}
	declarations {
		&|vectorAlias| : Vector[*StructName] {
			name = "..."
			request = "..."
		},
		*period[PER_AliasPeriod] {
			name = "..."
			description = "..."
			tags {
				"...", "..."
			}
			declarations {
				&<objectAlias> : StructName
			}
			operation {
				print {
					[version = "..."],
					[version = "...", name = "Pero Vaz de Caminha"]
				}
			}
		}
	}
	operation {
		foreach (<elem> IN |vectorAlias| /*: <elem>.mandatory == "&" <--- dar esse poder?*/) {
			use period[XXX_Alias] where ( <innerElem> = <elem> ),
			print { version = "..." }
		}
	}
}

/* SUJEITO */
list[SLV01_Gender1_LIST01] {
	name = "Lista Idiota"
	options = ("Masculino", "Feminino")
	type = "String"
}

*branch[SLV02_Rec2] {
	operations {
		use *branch[IUsed001_Alias]
	}
	declarations {
		*branch[SLV03_Rec3] {
			name = "Branch Idiota"
			operations {
				use *branch[IUsed002_Alias]
			}
			declarations {
				*list[SLV04_AliasList4_LIST02] {
					options = ("Option1", "Option2")
					type = "String"
				},
				*list[SLV05_AliasList5_LIST03] {
					options = ("Option1", "Option2")
					type = "String"
				},
				*period[SLV06_Rec6] {
					declarations {
						*period[SLV07_Rec7] {
							operation {
								print {
									version = "..."
								}
							}
						},
						*list[SLV08_AliasList8_LIST04] {
							options = ("Option1", "Option2")
							type = "String"
						}
					}
					operation {
						print {
							[version = "...", name = "Sirilampo"],
							[name = "Sarilampo", version = "..."],
							[version = "Ops"]
						}
					}
				}
			}
		}
	}
}

*struct[SLV09_Nome9] {
	request = "Por favor preencha os dados do sujeito."
	fields {
		-[isop001_tratamento] : String {
			name = "Pronome de tratamento"
			key = false
			help = "Por exemplo: Sr., Sra., Dra., Exmo., Ilmo.."
		},
		&[isop002_prenome] : String {
			name = "Prenome"
			key = true
			help = "Prenome significa o(s) primeiro(s) nome(s) da pessoa. Por exemplo: Rafael,
					Maria José, Joaquim."
		},
		-[isop003_sobrenomeMeio] : String {
			name = "Sobrenome(s) do meio"
			key = true
			help = "Sobrenomes do meio são os sobrenomes que antecedem o último sobrenome."
		},
		&[isop004_sobrenomeUltimo] : String {
			name = "Último sobrenome"
			key = true
			help = "Exemplos: de Oliveira, Ribeiro, Pinheiro Neto. O último sobrenome deve incluir o agnome (partícula
					que tem a função de diferenciar pessoas da mesma família que possuem o mesmo prenome e sobrenome
					(Filho, Neto, Sobrinho etc.))."
		}
	}
}

struct[SLV10_RepresentanteIncapaz10] extends Sujeito where ([extwhere01_capacidade] = "Capaz",
										  [extwhere02_tipoDePessoa] = "Pessoa natural",
										  [extwhere03_personificacao] = "Personificado") {
	fields {
		&[isop005_alcunha_LIST05] : List("Pai", "Mãe", "Tutor", "Curador") {
			name = "Tipo do representante"
			atomic = true
			key = false
			help = "Toda pessoa absoluta ou relativamente incapaz deve ter um representante ou
					assistente, que pode ser seu pai ou sua mãe ou, na ausência ou impedimento
					de ambos os pais, um tutor ou curador nomeado por um juíz. Via de regra, os
					os maiores de 16 anos e menores de 18 anos são assitidos por seus pais ou por
					seu tutor. Já os absolutamente incapazes geralmente são representados por um
					curador."
		}
	}
}

struct[SLV11_RepresentanteNascituro11] extends Sujeito where ( [extwhere04_capacidade] = "Capaz",
							  			   [extwhere05_tipoDePessoa] = "Pessoa natural",
							  			   [extwhere06_personificacao] = "Personificado") {
	fields {
		&[isop006_alcunha_LIST06] : List ("Mãe", "Curador", "Pai") {
			name = "Tipo do representante"
			atomic = true
			key = false
			help = "Todo nascituro deve ter um representante, que pode ser sua mãe, seu pai ou um curador
					nomeado por um juíz."
		}
	}
}

*struct[SLV12_Sujeito12] {
	request = "Por favor preencha os dados do sujeito."
	help = "Um sujeito é qualquer entidade, seja personificada ou não, que possa ser parte de um contrato,
			tenha legitimidade processual ou, de qualquer outra forma, possam assumir direitos e contrair
			obrigações, ainda que, para tanto, tenha que ser representada por uma pessoa. São exemplos de
			sujeito as pessoas naturais (físicas), as pessoas jurídicas (inclusive as de direito público
			interno e externo), os condomínios, os espólios, os fundos, as massas falidas e os órgãos da
			administração direta, como os ministérios, secretarias e departamentos."
	fields {
		&[isop007_genero] : List[*Gender_LIST07] {
			name = "Gênero do sujeito"
			atomic = true
			key = false
			help = ""
		},
		&[isop008_personificacao_LIST08] : List("01_Personificado_STRC", "Não personificado") {
			name = "Personificação do sujeito"
			atomic = true
			key = false
			default = "01_Personificado_STRC"
			help = "São sujeitos personificados tanto as pessoas naturais (físicas) como as juridicas."
		},
		&[isop009_domicilio] : List[SLV36_ListaDePaisesCom3Letras_LIST29] {
			name = "País de domicílio"
			atomic = false
			key = false
			default = {"02_BRA_STRC", "03_BRA_STRC"} /* TODO: CHECAR ISSO */
			help = "Informe a sigla do país do logradouro. Por exemplo, \"BRA\"."
		},
		-|isop010_logradouros| : Vector[*Logradouro] {
			request = "Por favor informe o " & position() & "^{o} endereço."
		},
/*SUJEITO PERSONIFICADO*/
		if ( [personificacaoDoIf1] == "Personificado" ) {
			&[isop011_tipoDePessoa_LIST10] : List("Pessoa natural", "Pessoa jurídica") {
				name = "Tipo de pessoa"
				atomic = true
				key = false
				help = "Pessoas naturais ou físicas são os seres humanos. As pessoas jurídicas são entidades incorpóreas,
						cuja personalidade deriva da lei ou de um registro."
			},
			     /*valores {super abreviado, abreviado, extenso} */
			&[isop012_pais_LIST11] : List({"BR","BRA","Brasil"}, {"US","USA","Estados Unidos"}) {
				name = "Tipo de pessoa"
				atomic = true
				key = false
				help = "Pessoas naturais ou físicas são os seres humanos. As pessoas jurídicas são entidades incorpóreas,
						cuja personalidade deriva da lei ou de um registro."
			}
		},
		if ( [personificacaoDoIf2] == "Personificado" ) {
			&[isop013_tipoDePessoa_LIST12] : List("Pessoa natural", "Pessoa jurídica") {
				name = "Tipo de pessoa"
				atomic = true
				key = false
				help = "Pessoas naturais ou físicas são os seres humanos. As pessoas jurídicas são entidades incorpóreas,
						cuja personalidade deriva da lei ou de um registro."
			},
/*PESSOA NATURAL*/
			if ( [tipoDePessoa] == "Pessoa natural" ) {
				&[isop014_capacidade_LIST13] : List("Capaz", "Relativamente incapaz", "Incapaz") {
					name = "Capacidade civil da pessoa"
					atomic = true
					key = false
					help = "Segundo a lei brasileira, a lei do país em que a pessoa for domiciliada determina as regras
					sobre a capacidade. Caso o sujeito não seja residente no Brasil, as regras de capacidade seguirão o
					direito do país onde o sujeito residir. Se a pessoa for domiciliada no Brasil, em geral é considerada
					capaz se tiver idade igual ou superior a 18 anos. No Brasil, um menor se tornará
					capaz nas seguintes hipóteses: (1) pela concessão dos pais, ou de um deles na falta do outro, mediante
					instrumento público, independentemente de homologação judicial, ou por sentença do juiz, ouvido o
					tutor, se o menor tiver 16 anos completos; (2) pelo casamento; (3) pelo exercício de emprego público
					efetivo; (4) pela colação de grau em curso de ensino superior; ou (5) pelo estabelecimento civil ou
					comercial, ou pela existência de relação de emprego, desde que, em função deles, o menor com 16 anos
					completos tenha economia própria. No Brasil, são relativamente incapazes: (1) os maiores de 16 e menores de 18 anos;
					(2) os ébrios habituais, os viciados em tóxicos, e os que, por deficiência mental, tenham o
					discernimento reduzido; (3) os excepcionais, sem desenvolvimento mental completo; e (4) os pródigos.
					No Brasil, são absolutamente incapazes de exercer pessoalmente os atos da vida civil: (1) os menores de 16 anos;
					(2) os que, por enfermidade ou deficiência mental, não tiverem o necessário discernimento para a prática
					dos atos da vida civil; (3) os que, mesmo por causa transitória, não puderem exprimir sua vontade."
				},
				-|isop015_profissoes| : Vector[String] {
					request = "Por favor informe a " & position() & "^{a} profissão/ocupação."
					name = "Profissão ou ocupação"
					help = "Se a pessoa tiver mais que uma profissão ou ocupação, informe todas. A primeira profissão ou ocupação
							informada será considerada padrão. Exemplo: professor, advogado."
				},
				-[isop016_estadoCivil_LIST14] : List("Solteiro", "Casado", "Convivente estável", "Divorciado", "Viúvo") {
					name = "Estado civil"
					atomic = true
					key = false
					help = "No Brasil, os estados civis admitidos são: solteiro, casado, divorciado e viúvo.
							A união estável foi incluída no rol de estados civis porque tem características comuns ao
							casamento."
				},
				if ([estadoCivil] == "Casado" OR [estadoCivil] == "Convivente estável") {
					-[isop017_regimeBens_LIST15] : List("comunhão total de bens", "comunhão parcial de bens", "separação total de bens",
							 "participação final nos aquestos") {
						name = "Regime de bens"
						atomic = true
						key = false
						help = "Não havendo pacto antenupcial, o regime é de comunhão parcial de bens."
					}
				},
				&[isop018_nome] : Nome {
					name = "Regime de bens"
				},
				&[isop019_dataNascimento] : Date {
					name = "Data de nascimento"
					key = false
					help = "Informe a data de nascimento no formato dd/mm/aaaa."
				},
				&[isop020_nacionalidadeGeral_LIST16] : List("Brasileiro", "03_Estrangeiro_STRC") {
					name = "Nacionalidade geral (brasileiro x estrangeiro)"
					atomic = true
					key = false
					default = "03_Estrangeiro_STRC"
				},
				if ( [nacionalidadeGeral] == "Estrangeiro" ) {
					&[isop021_nacionalidadeEstrangeiro] : String {
						name = "Especificação da nacionalidade do estrangeiro"
						key = false
						help = "Especificação da nacionalidade do estrangeiro."
					}
				},
				/* TODO: Checar se está fazendo a validação direitinho */
				&[isop022_cpf] : String where("CPF") {
					name = "Número do CPF"
					key = true
					help = "Número de inscrição no Cadastro de Pessoas Físicas (CPF) da Secretaria da Receita
							Federal do Brasil - RFB."
				},
				if ( [domicilio] == "BRA" ) {
					if ( [capacidade] == "Incapaz" OR [capacidade] == "Relativamente incapaz" ) {
						&[isop023_representante] : RepresentanteIncapaz
					}
				},
				if ( EXISTS <adv> IN |profissoes| : <adv>.lowercase() == "advogado"
					OR EXISTS <adv> IN |profissoes| : <adv>.lowercase() == "advogada"  ) {
					-|isop024_oab| : Vector[*Oab] {
						request = "Por favor informe os dados da " & position() & "^{a} inscrição."
					}
				},
/*PESSOA NATURAL BRASILEIRA*/
				if ( [nacionalidade] == "Brasileiro" ) {
					-[isop025_rg] : *RegistroGeral
				} else {
/*PESSOA NATURAL ESTRANGEIRA*/
					-[isop026_rne] : *RegistroNacionalEstrangeiro
				}
			} else {
/*PESSOA JURÍDICA*/
				&[isop027_denominacao] : String {
					name = "Denominação, firma ou razão social."
					key = true
					help = "A denominação, firma ou razão social devem ser informados integralmente. No
							caso de sociedade, a razão social deve conter o tipo societário correspondente, como nos
							seguintes casos: Mercearia do José Ltda., Looplex S.A."
				},
				&[isop028_ramoDireito_LIST17] : List("Direito público externo", "Direito público interno", "Direito privado") {
					name = "Ramo do direito (direito público x direito privado)"
					atomic = true
					key = false
					help = "As pessoas jurídicas têm sua personalidade atrelada a uma lei ou a um registro em determinado órgão. As pessoas jurídicas
							de direito privado se atrelam ao registro no órgão competente, e as de direito público, à lei. As
							pessoas jurídicas de direito privado incluem as fundações, associações e sociedades. As pessoas
							jurídicas de direito público podem ser de direito interno ou externo. As de direito externo incluem
							a representação jurídica de países e organismos internacionais (como a ONU). As de direito interno
							incluem os Estados, o Distrito Federal e os Municípios, além de outros entes que formam a administração
							pública brasileira, como empresas públicas, autarquias e sociedades de economia mista."
				},
				-[isop029_dataConstituicao] : Date {
				 	name = "Data de constituição da pessoa jurídica"
				 	key = true
				 	help = "A data de constituição da pessoa jurídica deve estar no formato dd/mm/aaaa. A data de constituição não
				 			se confunde com a data de registro dos atos constitutivos da pessoa jurídica no seu respectivo órgão de
				 			registro (por exemplo, Junta Comercial)."
				},
/*PESSOA JURÍDICA DIREITO PÚBLICO EXTERNO*/
				if ( [ramoDireito] == "Direito público externo" ) {
					&[isop030_tipo_LIST18] : List ("País", "Divisão administrativa de país", "Organismo internacional", "Santa Sé") {
						name = "Tipo de pessoa jurídica de direito público externo"
						atomic = true
						key = false
						help = ""
					}
				},
/*PESSOA JURÍDICA DIREITO PÚBLICO INTERNO*/
				if ( [ramoDireito] == "Direito público interno" ) {
					&[isop031_tipo_LIST19] : List ("União", "Estado", "Distrito Federal", "Território", "Município", "Autarquia",
									"Empresa pública", "Empresa pública binacional", "Sociedade de economia mista",
									"Fundação pública") {
						name = "Tipo de pessoa jurídica de direito público interno"
						atomic = true
						key = false
						help = ""
					},
					&[isop032_normativo] : String {
						name = "Principal lei ou outro normativo que determina a criação e funcionamento da pessoa jurídica de direito
								 público interno"
						key = false
						help = "Por exemplo, o normativo principal que regulamenta a Comissão de Valores Mobiliários (CVM) é a Lei Federal
								nº 6.385, de 7 de dezembro de 1976."
					},
					if ( [tipo] == "Empresa pública" OR [tipo] == "Empresa pública binacional" OR [tipo] == "Sociedade de economia mista" ) {
						-[isop033_inscricaoEstadual] : *InscricaoEstadual,
						-[isop034_atosConstitutivos] : *AtosConstitutivos,
						&[isop035_cnpj] : String where("CNPJ") {
							name = "CNPJ - Cadastro Nacional de Pessoas Jurídicas"
							key = true
							help = ""
						}
					},
					if ( [tipo] == "Autarquia" OR [tipo] == "Empresa pública" OR [tipo] == "Empresa pública binacional" OR [tipo] == "Sociedade de economia mista"
						 OR [tipo] == "Fundação pública") {
						-[isop036_vinculacao] : String {
							name = "Vinculação a órgão da administração pública federal"
							key = false
							help = "Todas as autarquias, fundações públicas, empresas públicas e sociedades de economia mista são vinculadas a um órgão da
									administração pública federal. Exemplo: a Companhia de Entrepostos e Armazéns Gerais de São Paulo - CEAGESP está vinculada
									ao Ministério da Agricultura, Pecuária e Abastecimento e a Agência Nacional de Vigilância Sanitária - ANVISA está vinculada
									ao Ministério da Saúde."
						}
					}
				},
/*PESSOA JURÍDICA DIREITO PRIVADO*/
				if ( [ramoDireito] == "Direito privado" ) {
					&[isop037_tipo_LIST20] : List ("Empresa individual de responsabilidade limitada (EIRELI)", "Sociedade", "Associação", "Fundação", "Partido político",
									"Organização religiosa") {
						name = "Tipo de pessoa jurídica de direito privado"
						atomic = true
						key = false
						help = ""
					},
					&[isop038_cnpj] : String where("CNPJ") {
						name = "CNPJ - Cadastro Nacional de Pessoas Jurídicas"
						key = true
						help = ""
					},
					if ( [tipo] == "Sociedade" OR [tipo] == "Associação" OR [tipo] == "Fundação" OR [tipo] == "Empresa individual de responsabilidade limitada") {
						-[isop039_inscricaoMunicipal] : *InscricaoMunicipal,
						-[isop040_inscricaoEstadual] : *InscricaoEstadual,
						-[isop041_atosConstitutivos] : *AtosConstitutivos
					},
					if ( [tipo] == "Sociedade" ) {
						&[isop042_sociedade_LIST21] : List("Sociedade simples pura", "Sociedade simples limitada", "Sociedade de advogados", "Sociedade em nome coletivo",
											"Sociedade em comandita simples", "Sociedade empresarial limitada", "Sociedade por ações", "Sociedade em
											comandita por ações", "Sociedade Cooperativa") {
							name = "Tipos societários"
							atomic = true
							key = false
							help = "Sociedades simples são aquelas em que os sócios exercem as suas profissões, ou seja, a
									prestação de serviço tem natureza estritamente pessoal (por exemplo, sociedade de médicos), e seus atos
									constitutivos são registrados em cartório (Registro Civil de Pessoa Jurídica), com exceção da sociedade
									de advogados, cujos contrato social é registrado na Secional da Ordem dos Advogados do Brasil que tenha
									jurisdicão sobre ela. A diferença entre a sociedade simples pura e a sociedade simples limitada é
									que, na primeira, a responsabilidade dos sócios é ilimitada e, na segunda, a responsabilidade dos
									sócios é limitada ao montante do capital social. As sociedades empresárias têm por objeto o exercício,
									de forma profissional, de atividade econômica organizada para a produção e/ou circulação de bens ou
									de serviços, e seus atos constitutivos são registrados na Junta Comercial da unidade da federação em
									que se situa a sede da sociedade (por exemplo, Junta Comercial do Estado de São Paulo – JUCESP). A
									denominação das sociedades por ação necessariamente contém as expressões \"S.A.\" ou \"S/A\" ou \"Companhia\".
									Se a S.A. tem seus valores mobiliários (por exemplo, ações) admitidos à negociação em mercado de valores
									mobiliários (por exemplo, bolsa de valores), então essa S.A. é de capital aberto. As sociedades em nome
									coletivo possuem o nome de um ou mais de seus sócios e sua denominação contém necessariamente a
									expressão \'& Companhia\'."
						}
					}
				}
			}
		} else {
/*SUJEITO NÃO PERSONIFICADO*/
			&[isop043_tipo_LIST22] : List("Fundo de investimento", "Condomínio (edilício)", "Condomínio (geral)", "Massa falida", "Espólio", "Herança jacente",
						   "Órgão público", "Consórcio ou grupo de sociedades", "Clube de investimento", "Sociedade em comum", "Sociedade em conta de
						   participação", "Representação diplomática do Estado brasileiro no exterior", "Representação diplomática estrangeira
						   no Brasil", "Representação permanente de organização internacional ou de instituição extraterritorial no Brasil",
						   "Serviço notarial ou de registro", "Consório de empregadores", "Fundo público de natureza meramente contábil",
						   "Unidade autônoma de incorporadora optante pelo Regime Especial de Tributação (RET)", "Candidato a cargo político
						   eletivo (inclusive vice e suplente)", "Comitê financeiro de partido político", "nascituro") {
				name = "Tipos de sujeitos não personficados"
				atomic = true
				key = false
				/* TODO: help = "..." */
			},
			if ( [tipo] == "Nascituro" ) {
				&[isop044_representante] : RepresentanteNascituro
			},
			if ( [tipo] == "Fundo de investimento" OR [tipo] == "Condomínio (edilício)" OR [tipo] == "Massa falida" OR [tipo] == "Órgão público"
						   OR [tipo] == "Consórcio ou grupo de sociedades" OR [tipo] == "Clube de investimento" OR [tipo] == "Representação diplomática
						   do Estado brasileiro no exterior" OR [tipo] == "Representação diplomática estrangeira no Brasil" OR [tipo] == "Representação
						   permanente de organização internacional ou de instituição extraterritorial no Brasil" OR [tipo] == "Serviço notarial ou de
						   registro" OR [tipo] == "Consório de empregadores" OR [tipo] == "Fundo público de natureza meramente contábil" OR [tipo] == "Unidade
						   autônoma de incorporadora optante pelo Regime Especial de Tributação (RET)" OR [tipo] == "Candidato a cargo político eletivo
						   (inclusive vice e suplente)" OR [tipo] == "Comitê financeiro de partido político" ) {
				&[isop045_cnpj] : String where("CNPJ") {
					name = "CNPJ - Cadastro Nacional de Pessoas Jurídicas"
					key = true
					help = ""
				}
			},
			if ( [tipo] == "Espólio" ) {
				&[isop046_inventariante] : Inventariante extends Sujeito where ([extwhere07_capacidade] = "Capaz",
											  			   [extwhere08_tipoDePessoa] = "Pessoa natural",
											  			   [extwhere09_personificacao] = "Personificado")
			}
		}
	}
}

*branch[SLV13_BRC_qualificacaoPessoaNaturalCapaz13] {
	description = "Branch de qualificação de pessoa natural capaz"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz"}
	declarations {
		&<inop047_varAlias> : String {
			tip = "..."
			help = "..."
			default = "04_..._NODE_ONLY"
			request = "..."
		},
		&<inop048_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed003_PER_qualificacaoPessoaNaturalCapaz],
		 use *dependency[IUsed004_DEP_qualificacaoLogradouro] where (<where01_endereco> = <pessoa.logradouros>.select()),
 		<attrib01_varAlias> = "Teste"
	}
}

*period[SLV14_PER_qualificacaoPessoaNaturalCapaz14] {
	description = "Período de qualificação de pessoa natural capaz"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz"}
	operation {
		print {
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa.nacionalidadeGeral>
						& ", "
						& printIf ( NOT <pessoa.estadoCivil>.isEmpty(), <pessoa.estadoCivil>
									& printIf (<pessoa.estadoCivil> == "Casado" OR <pessoa.estadoCivil> == "Convivente estável",
					                " em regime de " & <pessoa.regimeBens> & ", ", ", "))
						& printIf (NOT <pessoa.profissoes>.isEmpty(), versionize(<pessoa.profissoes>.select() & ", ", ""))
						& printIf (NOT <pessoa.rg>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " da cédula de identidade (RG) nº~"
					   															& <pessoa.rg.numero>
					   															& "("
					   															& <pessoa.rg.orgaoEmissor>
					   															& "/"
					   															& <pessoa.rg.uf>
					   															& "), ")
						& printIf (NOT <pessoa.rne>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " da cédula de registro nacional de estrangeiro (RNE) nº~"
					   															& <pessoa.rne.numero>
					   															& ", ")
						& printIf (NOT <pessoa.passaporte>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " do passaporte "
					   															& <pessoa.passaporte.nacionalidadePaisEmissor>
					   															& " nº~"
					   															& <pessoa.passaporte.numero>
					   															& ", ")
					   	& versionize 	(printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   				  	& " no CPF/MF sob o nº~" & <pessoa.cpf>),
					   					printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   					& " no Cadastro de Pessoas Físicas do Ministério da Fazenda (CPF/MF) sob o nº~"
					   					& <pessoa.cpf>))
					   	& ", residente e "
					   	& <pessoa>.grammar ("domiciliado")
					   	& " em" & isEmpty(<bostaComCaramelo>)
			]
		}
	}
	declarations {
		&<inop049_pessoa> : externs *Sujeito
	}
}

/*PESSOA NATURAL RELATIVAMENTE INCAPAZ - VERSÃO EXTENSA*/

*branch[SLV15_BRC_qualificacaoPessoaNaturalRelativamenteIncapazExtenso15] {
	description = "Branch de qualificação de pessoa natural relativamente incapaz - versão extensa"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Versão extensa"}
	declarations {
		&<inop050_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed005_PER_qualificacaoPessoaNaturalNaoCapazExtenso],
		 use *dependency[IUsed006_DEP_qualificacaoLogradouro] where (<where02_endereco> = <pessoa.logradouros>.select()),
		 use *period[IUsed007_PER_qualificacaoRepresentanteDaPessoaNaturalRelativamenteIncapaz] where (<where03_representante> = <pessoa.representante>),
		 use *period[IUsed008_PER_qualificacaoPessoaNaturalCapaz] where (<where04_pessoa> = <pessoa.representante>)
	}
}

*period[SLV16_PER_qualificacaoPessoaNaturalNaoCapazExtenso16] {
	description = "Período de qualificação de pessoa natural que não seja capaz - versão extensa"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Incapaz", "Versão extensa"}
	operation {
		print {
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa.nacionalidadeGeral>
						& ", "
						& printIf (<pessoa.idade> < 18, "menor "
									& <pessoa>.grammar ("nascido")
									& " em "
									& <pessoa.dataNascimento>
									& ", ")
						& printIf ( NOT <pessoa.estadoCivil>.isEmpty(), <pessoa.estadoCivil>
									& printIf (<pessoa.estadoCivil> == "Casado" OR <pessoa.estadoCivil> == "Convivente estável",
					                " em regime de " & <pessoa.regimeBens> & ", ", ", "))
						& printIf (NOT <pessoa.profissoes>.isEmpty(), versionize(<pessoa.profissoes>.select() & ", ", ""))
						& printIf (NOT <pessoa.rg>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " da cédula de identidade (RG) nº~"
					   															& <pessoa.rg.numero>
					   															& "("
					   															& <pessoa.rg.orgaoEmissor>
					   															& "/"
					   															& <pessoa.rg.uf>
					   															& "), ")
					   	& versionize 	(printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   				  	& " no CPF/MF sob o nº~" & <pessoa.cpf>),
					   					printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   					& " no Cadastro de Pessoas Físicas do Ministério da Fazenda (CPF/MF) sob o nº~"
					   					& <pessoa.cpf>))
					   	& ", residente e "
					   	& <pessoa>.grammar ("domiciliado")
					   	& " em"
			]
		}
	}
	declarations {
		&<inop051_pessoa> : externs *Sujeito
	}
}

*period[SLV17_PER_qualificacaoRepresentanteDaPessoaNaturalRelativamenteIncapaz17] {
 	description = "Período de qualificação do representante de pessoa natural relativamente incapaz"
 	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Representante", "Curador", "Curadora", "Tutor", "Tutora", "Pai", "Mãe"}
 	operation {
		print {
	 		[version =	", neste ato "
						& <representante>.grammar ("assistido")
						& " por "
						& <representante>.grammar ("seu")
						& " "
						& <representante.alcunha>
						& ", "
			]
		}
	}
 	declarations {
 		&<inop052_representante> : externs *Sujeito
	}
}

/*PESSOA NATURAL RELATIVAMENTE INCAPAZ - VERSÃO ABREVIADA*/

*branch[SLV18_BRC_qualificacaoPessoaNaturalRelativamenteIncapazAbreviado18] {
	description = "Branch de qualificação de pessoa natural relativamente incapaz - versão abreviada"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Versão abreviada"}
	declarations {
		&<inop053_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed009_PER_qualificacaoPessoaNaturalNaoCapazAbreviado],
		 use *period[IUsed010_PER_qualificacaoRepresentanteDaPessoaNaturalRelativamenteIncapaz] where (<where05_representante> = <pessoa.representante>, <where06_pessoa> = <pessoa.representante>),
		 use *period[IUsed011_PER_qualificacaoPessoaNaturalCapaz]
	}
}

*period[SLV19_PER_qualificacaoPessoaNaturalNaoCapazAbreviado19] {
	description = "Período de qualificação de pessoa natural que não seja capaz - versão abreviada"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Incapaz", "Versão extensa"}
	operation {
		print {
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa.nacionalidadeGeral>
						& ", "
						& printIf (<pessoa.idade> < 18, "menor "
									& <pessoa>.grammar ("nascido")
									& " em "
									& <pessoa.dataNascimento>
									& ", " )
						& printIf ( NOT <pessoa.estadoCivil>.isEmpty(), <pessoa.estadoCivil>
									& printIf (<pessoa.estadoCivil> == "Casado" OR <pessoa.estadoCivil> == "Convivente estável",
					                " em regime de " & <pessoa.regimeBens> & ", ", ", "))
						& printIf (NOT <pessoa.profissoes>.isEmpty(), versionize(<pessoa.profissoes>.select() & ", ", ""))
						& printIf (NOT <pessoa.rg>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " da cédula de identidade (RG) nº~"
					   															& <pessoa.rg.numero>
					   															& "("
					   															& <pessoa.rg.orgaoEmissor>
					   															& "/"
					   															& <pessoa.rg.uf>
					   															& "), ")
					   	& versionize 	(printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   				  	& " no CPF/MF sob o nº~" & <pessoa.cpf>),
					   					printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   					& " no Cadastro de Pessoas Físicas do Ministério da Fazenda (CPF/MF) sob o nº~"
					   					& <pessoa.cpf>))
			]
		}
	}
	declarations {
		&<inop054_pessoa> : externs *Sujeito
	}
}

/*PESSOA NATURAL INCAPAZ - VERSÃO EXTENSA*/

*branch[SLV20_BRC_qualificacaoPessoaNaturalIncapazExtenso20] {
	description = "Branch de qualificação de pessoa natural incapaz - versão extensa"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Incapaz", "Versão extensa"}
	declarations {
		&<inop055_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed012_PER_qualificacaoPessoaNaturalNaoCapazExtenso],
		 use *dependency[IUsed013_DEP_qualificacaoLogradouro] where (<where07_endereco> = <pessoa.logradouros>.select()),
		 use *period[IUsed014_PER_qualificacaoRepresentanteDaPessoaNaturalIncapaz] where (<where08_representante> = <pessoa.representante>),
		 use *period[IUsed015_PER_qualificacaoPessoaNaturalCapaz] where (<where09_pessoa> = <pessoa.representante>)
	}

}

*period[SLV21_PER_qualificacaoRepresentanteDaPessoaNaturalIncapaz21] {
 	description = "Período de qualificação do representante de pessoa natural relativamente incapaz"
 	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Relativamente incapaz", "Representante", "Curador", "Curadora", "Tutor", "Tutora", "Pai", "Mãe"}
 	operation {
		print {
	 		[version =	", neste ato "
						& <representante>.grammar ("representado")
						& " por "
						& <representante>.grammar ("seu")
						& " "
						& <representante.alcunha>
						& ", "]
		}
	}
 	declarations {
 		&<inop056_representante> : externs *Sujeito
	}
}

/*PESSOA NATURAL INCAPAZ - VERSÃO ABREVIADA*/

*branch[SLV22_BRC_qualificacaoPessoaNaturalIncapazAbreviado22] {
	description = "Branch de qualificação de pessoa natural  incapaz - versão abreviada"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Incapaz", "Versão abreviada"}
	declarations {
		&<inop057_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed016_PER_qualificacaoPessoaNaturalNaoCapazAbreviado],
		 use *period[IUsed017_PER_qualificacaoRepresentanteDaPessoaNaturalIncapaz] where (<where10_representante> = <pessoa.representante>),
		 use *period[IUsed018_PER_qualificacaoPessoaNaturalCapaz] where (<where11_pessoa> = <pessoa.representante>)
	}
}

*branch[SLV23_BRC_qualificacaoAdvogadoOABExtenso23] {
	description = "Branch de qualificação de advogado registrado na OAB - versão extensa"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz", "Advogado", "Advogada", "OAB", "Versão extensa"}
	declarations {
		&<inop058_pessoa> : externs *Sujeito
	}
	operations {
		 use *period[IUsed019_PER_qualificacaoAdvogadoOABExtenso],
		 use *dependency[IUsed020_DEP_qualificacaoLogradouro] where (<where12_endereco> = <pessoa.logradouros>.select())
	}
}

*period[SLV24_PER_qualificacaoAdvogadoOABExtenso24] {
	description = "Período de qualificação de advogado registrado na OAB - versão extensa"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz", "Advogado", "Advogada", "OAB", "Versão extensa"}
	operation {
		print {
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa.nacionalidadeGeral>
						& ", "
						& printIf ( NOT <pessoa.estadoCivil>.isEmpty(), <pessoa.estadoCivil>
									& printIf (<pessoa.estadoCivil> == "Casado" OR <pessoa.estadoCivil> == "Convivente estável",
					                " em regime de " & <pessoa.regimeBens> & ", ", ", "))
						& <pessoa>.grammar ("advogado")
						& " "
						& <pessoa>.grammar ("inscrito")
						& " na Ordem dos Advogados do Brasil (OAB), Seção "
						& <pessoa.oab.secionalExtenso>
						& ", sob o nº~"
						& <pessoa.oab.numero>
					  	& ", "
						& printIf (NOT <pessoa.rg>.isEmpty(), <pessoa>.grammar ("portador")
					   															& " da cédula de identidade (RG) nº~"
					   															& <pessoa.rg.numero>
					   															& "("
					   															& <pessoa.rg.orgaoEmissor>
					   															& "/"
					   															& <pessoa.rg.uf>
					   															& "), ")
					   	& versionize 	(printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   				  	& " no CPF/MF sob o nº~" & <pessoa.cpf>),
					   					printIf (NOT <pessoa.cpf>.isEmpty(), <pessoa>.grammar ("inscrito")
					   					& " no Cadastro de Pessoas Físicas do Ministério da Fazenda (CPF/MF) sob o nº~"
					   					& <pessoa.cpf>))
					   	& ", residente e "
					   	& <pessoa>.grammar ("domiciliado")
					   	& " em"
			]
		}
	}
	declarations {
		&<inop059_pessoa> : externs *Sujeito
	}
}


/*QUALIFICAÇÃO DE ADVOGADO COM OAB - VERSÃO ABREVIADA*/

*branch[SLV25_BRC_qualificacaoAdvogadoOABAbreviado25] {
	description = "Branch de qualificação de advogado registrado na OAB - versão abreviada"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz", "Advogado", "Advogada", "OAB", "Versão abreviada"}
	declarations {
		&<inop060_pessoa> : externs *Sujeito,
		&<inop061_c> : StructAlias,
		*struct[SLV26_StructAlias26] {
			request = "..."
			help = "..."
			fields {
				&[isop062_fieldAlias] : Time {
					name = "fieldLabel"
					key = true
					default = "05_...NODE_ONLY"
					help = "..."
				},
				&[isop063_fieldStructAlias] : *StructName,
				&|isop064_vectorAlias_LIST23| : Vector[List("a","b","c")] {
					request = "..."
					name = "a11"
					atomic = true
					help = "..."
				},
				&|isop065_vectorAlias_LIST24| : Vector[List("1","2","3")] {
					request = "..."
					name = "a11"
					atomic = false
					help = "..."
				},
				&|isop066_vectorAlias| : Vector[*StructName] {
					request = "..."
				}
			}
		}
	}
	operations {
		 use *period[IUsed021_PER_qualificacaoAdvogadoOABAbreviado]
	}
}

*period[SLV27_PER_qualificacaoAdvogadoOABAbreviado27] {
	description = "Período de qualificação de advogado registrado na OAB - versão abreviada"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Capaz", "Advogado", "Advogada", "OAB", "Versão abreviada"}
	operation {
		print {
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa>.grammar ("advogado")
						& " "
						& <pessoa>.grammar ("inscrito")
						& "na Ordem dos Advogados do Brasil (OAB), Seção "
						& <pessoa.oab.secionalExtenso>
						& ", sob o nº~"
						& <pessoa.oab.numero>
			],
			[version = 	<pessoa.nome>
						& ", "
						& <pessoa>.grammar ("advogado")
						& " "
						& <pessoa>.grammar ("inscrito")
						& " na OAB/"
						& <pessoa.oab.secionalSigla>
						& ", sob o nº~"
						& <pessoa.oab.numero>
			]
		}
	}
	declarations {
		&<inop067_pessoa> : externs *Sujeito
	}
}

*branch[SLV28_BRC_qualificacaoPessoasJuridicasDireitoPrivadoExtendido28] {
	description = "Branch de qualificação de pessoas jurídicas de direito privado"
	tags {"Qualificação", "Pessoa jurídica", "Direito privado", "Empresa individual de responsabilidade limitada (EIRELI)", "Associação", "Fundação", "Partido político", "Organização religiosa", "Sociedade", "Sociedade simples pura", "Sociedade simples limitada", "Sociedade empresária limitada", "Sociedade limitada", "Sociedade em nome coletivo", "Sociedade em comandita simples", "Sociedade de advogados", "Sociedade por ações de capital aberto", "Sociedade por ações de capital fechado", "Sociedade em comandita por ações", "Sociedade cooperativa"}
	declarations {
		&<inop068_pessoaJuridica> : externs *Sujeito,
		&<inop069_pessoa> : *Sujeito {
			request = "..."
			help = "..."
		}
	}
	operations {
		 use *period[IUsed022_PER_qualificacaoPessoasJuridicasDireitoPrivadoIntroducao],
		 use *dependency[IUsed023_DEP_qualificacaoLogradouro] where (<where13_endereco> = <sociedadeLimitada.logradouros>.select()),
		 use *period[IUsed024_PER_qualificacaoPessoasJuridicasDireitoPrivadoContinuacao],
		 use *period[IUsed025_PER_qualificaçãoRepresentanteLegal] where (<where14_representanteLegal> = <sociedadeLimitada.representantes>.select()),
		 use *period[IUsed026_PER_qualificacaoPessoaNaturalCapaz] where (<where15_pessoa> = <sociedadeLimitada.representantes>.select()),
		 use *dependency[IUsed027_DEP_qualificacaoLogradouro] where (<where16_endereco> = <sociedadeLimitada.logradouros>.select())
	}
}

*period[SLV29_PER_qualificacaoPessoasJuridicasDireitoPrivadoIntroducao29] {
	description = "Período de qualificação de pessoas jurídicas de direito privado - introdução"
	tags {"Qualificação", "Pessoa jurídica", "Direito privado", "Empresa individual de responsabilidade limitada (EIRELI)", "Associação", "Fundação", "Partido político", "Organização religiosa", "Sociedade", "Sociedade simples pura", "Sociedade simples limitada", "Sociedade empresária limitada", "Sociedade limitada", "Sociedade em nome coletivo", "Sociedade em comandita simples", "Sociedade de advogados", "Sociedade por ações de capital aberto", "Sociedade por ações de capital fechado", "Sociedade em comandita por ações", "Sociedade cooperativa"}
	operation {
		print {
			[version = 	<pessoaJuridica.denominacao>
						& ", "
						& printIf (<pessoaJuridica.tipo> == "Empresa individual de responsabilidade limitada (EIRELI)", "empresa individual
															de responsabilidade limitada")
						& printIf (<pessoaJuridica.tipo> == "Associação", "associação")
						& printIf (<pessoaJuridica.tipo> == "Fundação", "fundação")
						& printIf (<pessoaJuridica.tipo> == "Partido político", "partido político")
						& printIf (<pessoaJuridica.tipo> == "Organização religiosa", "organização religiosa")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade simples pura", "sociedade simples")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade simples limitada", "sociedade simples limitada")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade empresária limitada", "sociedade empresária limitada")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade em nome coletivo", "sociedade em nome coletivo")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade em comandita simples", "sociedade em comandita simples")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade de advogados", "sociedade de advogados")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade por ações de capital aberto", "sociedade por ações de capital aberto")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade por ações de capital fechado", "sociedade por ações de capital fechado")
						& printIf (<pessoaJuridica.tipo.sociedade> == "Sociedade cooperativa", "sociedade cooperativa")
						& "com sede em "
			]
		}
	}
	declarations {
		&<inop070_pessoaJuridica> : externs *Sujeito
	}
}

*period[SLV30_PER_qualificacaoPessoasJuridicasDireitoPrivadoContinuacao30] {
	description = "Período de qualificação de pessoas jurídicas de direito privado - continuação"
	tags {"Qualificação", "Pessoa jurídica", "Direito privado", "Empresa individual de responsabilidade limitada (EIRELI)", "Associação", "Fundação", "Partido político", "Organização religiosa", "Sociedade", "Sociedade simples pura", "Sociedade simples limitada", "Sociedade empresária limitada", "Sociedade limitada", "Sociedade em nome coletivo", "Sociedade em comandita simples", "Sociedade de advogados", "Sociedade por ações de capital aberto", "Sociedade por ações de capital fechado", "Sociedade em comandita por ações", "Sociedade cooperativa"}
	operation {
		print {
			[version =	versionize 	("",	", e com seu "
											& <pessoaJuridica.atosConstitutivos.nome>
											& " registrado "
											& <pessoaJuridica.atosConstitutivos.orgaoRegistro>.grammar ("no")
											& " "
											& <pessoaJuridica.atosConstitutivos.orgaoRegistro>
											& " sob o nº~"
											& <pessoaJuridica.atosConstitutivos.numeroRegistro>
											& printIf (NOT <pessoaJuridica.atosConstitutivos>.isEmpty(), " em sessão de "
											& <pessoaJuridica.atosConstitutivos.dataRegistro>)
											& ", ")
						& <pessoaJuridica>.grammar ("inscrito")
						& versionize (" no Cadastro Nacional de Pessoas Jurídicas (CNPJ) sob o nº~", " no CNPJ sob o nº~")
						& <pessoaJuridica.pastaDeDocumentos.cnpj>
						& versionize ("", printIf (NOT <pessoaJuridica.inscricaoEstadual.numero>.isEmpty(), " inscrição estadual nº~"
																								& <pessoaJuridica.inscricaoEstadual.numero>
																								& ", ", ", "))
						& versionize ("", printIf (NOT <pessoaJuridica.inscricaoMunicipal.numero>.isEmpty(), " inscrição municipal nº~"
																								& <pessoaJuridica.inscricaoMunicipal.numero>
																								& ", ", ", "))
			],
			[version =	<pessoaJuridica>.grammar ("inscrito")
						& versionize (" no Cadastro Nacional de Pessoas Jurídicas (CNPJ) sob o nº~", " no CNPJ sob o nº~")
						& <pessoaJuridica.pastaDeDocumentos.cnpj>
			]
		}
	}
	declarations {
		&<inop071_pessoaJuridica> : externs *Sujeito
	}
}

*period[SLV31_PER_qualificaçãoRepresentanteLegal31] {
	description = "Período de qualificação de representante legal ou procurador de pessoa jurídica"
	tags {"Qualificação", "Pessoa natural", "Pessoa física", "Representante", "Representante legal", "Procurador", "Procuradora", "Administrador", "Administradora", "Diretor", "Diretora"}
	operation {
		print {
			[version =	", neste ato representada por "
						& <representanteLegal>.grammar ("seu")
						& " "
						& <representanteLegal.alcunha>
						& " "
			]
		}
	}
	declarations {
		&<inop072_representanteLegal> : externs *Sujeito
	}
}

*dependency[SLV32_DEP_qualificacaoLogradouro32] {
 	description = "Dependência de qualificação de logradouro"
 	tags {"Logradouro", "Endereço", "Localização"}
 	declarations {
		*period[SLV33_PER_qualificacaoLogradouroBrasileiro33] {
			description = "Período de qualificação de logradouro brasileiro"
			tags {"Logradouro", "Endereço", "Localização", "Brasileiro", "Brasileira"}
			declarations {
				&<inop073_endereco> : externs *Logradouro
			}
			operation {
				print {
					[version =	<endereco.principal>
								& ","
								& printIf (NOT <endereco.numero>.isEmpty(), " " & <endereco.numero> & ",", "")
								& printIf (NOT <endereco.complemento>.isEmpty(), " " & <endereco.complemento> & ",", "")
								& printIf (NOT <endereco.bairro>.isEmpty(), " " & <endereco.bairro> & ",", "")
								& " CEP nº~"
								& <endereco.codigoPostal>
								& ", na Cidade de "
								& <endereco.cidade>
								& ", "
								& printIf (<endereco.uf> == "Distrito Federal", "Distrito Federal", "Estado " &
									printIf(<endereco.uf> == "São Paulo" OR <endereco.uf> == "Alagoas" OR
											<endereco.uf> == "Goiás" OR <endereco.uf> == "Minas Gerais" OR
											<endereco.uf> == "Mato Grosso" OR <endereco.uf> == "Mato Grosso do Sul" OR
											<endereco.uf> == "Pernambuco" OR <endereco.uf> == "Rondônia" OR
											<endereco.uf> == "Roraima" OR <endereco.uf> == "Santa Catarina" OR <endereco.uf> == "Sergipe", "de ",
										printIf(<endereco.uf> == "Bahia" OR <endereco.uf> == "Paraíba" , "da ", "do "))  & <endereco.uf> )
								& versionize ("", ", " & <endereco.paisExtenso>)
					]
				}
			}
		},
		*period[SLV34_PER_qualificacaoLogradouroEstrangeiro34] {
			description = "Período de qualificação de logradouro estrangeiro"
			tags {"Logradouro", "Endereço", "Localização", "Estrangeiro", "Estrangeira"}
			declarations {
				&<inop074_endereco> : externs *Logradouro,
				*struct[SLV35_StructAlias35] {
					request = "..."
					help = "..."
					fields {
						&[isop075_fieldAlias] : Time {
							name = "fieldLabel"
							key = false
							help = "..."
						},
						&[isop076_fieldStructAlias] : *StructName
					}
				}
			}
			operation {
				print {
					[version =	<endereco.principal>
								& ","
								& printIf (NOT <endereco.complemento>.isEmpty(), " " & <endereco.complemento> & ",", "")
								& printIf (NOT <endereco.codigoPostal>.isEmpty(), " " & <endereco.codigoPostal> & ",", "")
								& printIf (NOT <endereco.cidade>.isEmpty(), " " & <endereco.cidade> & ",", "")
								& printIf (NOT <endereco.regiao>.isEmpty(), " " & <endereco.regiao> & ",", "")
								& <endereco.paisExtenso>
					]
				}
			}
		},
		&<inop077_teste_LIST25> : List("a","b","c") {
			atomic = true
			request = "..."
		},
		&<inop078_teste2_LIST26> : List("1","2","3") {
			atomic = false
			request = "..."
		},
		&<inop079_varAlias> : Boolean,
		&|inop080_vectorAlias| : Vector[String] {
			request = "..."
			name = "a11"
			help = "..."
		},
		&|inop081_vectorAlias_LIST27| : Vector[List("a","b","c")] {
			request = "..."
			name = "a11"
			atomic = true
			help = "..."
		},
		&|inop082_vectorAlias_LIST28| : Vector[List("1","2","3")] {
			request = "..."
			name = "a11"
			atomic = false
			help = "..."
		},
		&|inop083_vectorAlias| : Vector[*StructName] {
			request = "..."
		}
 	}
 	operation {
 		if (<endereco.paisExtenso> == "Brasil") {
  			use period[IUsed028_PER_qualificacaoLogradouroBrasileiro]
 		} elseif (<endereco.paisExtenso> == "Portugal") {
  			use period[IUsed029_PER_qualificacaoLogradouroBrasileiro]
 		} else {
 			use period[IUsed030_PER_qualificacaoLogradouroEstrangeiro]
 		}
 	}
}

*list[SLV36_ListaDePaisesCom3Letras_LIST29] {
	options = ("BRA", "USA", "ESP", "ABW", "AFG", "AGO", "AIA", "ALA", "ALB", "AND",
					   "ANT", "ARE", "ARG", "ARM", "ASM", "ATA", "ATF", "ATG", "AUS", "AUT",
					   "AZE", "BDI", "BEL", "BEN", "BFA", "BGD", "BGR", "BHR", "BHS", "BIH",
					   "BLM", "BLR", "BLZ", "BMU", "BOL", "BRB", "BRN", "BTN", "BVT", "BWA",
					   "CAF", "CAN", "CCK", "CHE", "CHL", "CHN", "CIV", "CMR", "COD", "COG",
					   "COK", "COL", "COM", "CPV", "CRI", "CUB", "CXR", "CYM", "CYP", "CZE",
					   "DEU", "DJI", "DMA", "DNK", "DOM", "DZA", "ECU", "EGY", "ENG", "ERI",
					   "ESH", "EST", "ETH", "FIN", "FJI", "FLK", "FRA", "FRO", "FSM", "GAB",
					   "GBR", "GEO", "GGY", "GHA", "GIB", "GIN", "GLP", "GMB", "GNB", "GNQ",
					   "GRC", "GRD", "GRL", "GTM", "GUF", "GUM", "GUY", "HKG", "HMD", "HND",
					   "HRV", "HTI", "HUN", "IDN", "IMN", "IND", "IOT", "IRL", "IRN", "IRQ",
					   "ISL", "ISR", "ITA", "JAM", "JEY", "JOR", "JPN", "KAZ", "KEN", "KGZ",
					   "KHM", "KIR", "KNA", "KOR", "KWT", "LAO", "LBN", "LBR", "LBY", "LCA",
					   "LIE", "LKA", "LSO", "LTU", "LUX", "LVA", "MAC", "MAF", "MAR", "MCO",
					   "MDA", "MDG", "MDV", "MEX", "MHL", "MKD", "MLI", "MLT", "MMR", "MNE",
					   "MNG", "MNP", "MOZ", "MRT", "MSR", "MTQ", "MUS", "MWI", "MYS", "MYT",
					   "NAM", "NCL", "NER", "NFK", "NGA", "NIC", "NIR", "NIU", "NLD", "NOR",
					   "NPL", "NRU", "NZL", "OMN", "PAK", "PAN", "PCN", "PER", "PHL", "PLW",
					   "PNG", "POL", "PRI", "PRK", "PRT", "PRY", "PSE", "PYF", "QAT", "REU",
					   "ROU", "RUS", "RWA", "SAU", "SCO", "SDN", "SEN", "SGP", "SGS", "SHN",
					   "SJM", "SLB", "SLE", "SLV", "SMR", "SOM", "SPM", "SRB", "STP", "SUR",
					   "SVK", "SVN", "SWE", "SWZ", "SYC", "SYR", "TCA", "TCD", "TGO", "THA",
					   "TJK", "TKL", "TKM", "TLS", "TON", "TTO", "TUN", "TUR", "TUV", "TWN",
					   "TZA", "UGA", "UKR", "UMI", "URY", "UZB", "VAT", "VCT", "VEN", "VGB",
					   "VIR", "VNM", "VUT", "WAL", "WLF", "WSM", "YEM", "ZAF", "ZMB", "ZWE")
	type = "String"
}

*struct[SLV37_PastaDeDocumentos37] {
	fields {
		&[isop084_pais] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop085_unidadeFederacao] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop086_cpf] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop087_cnpj] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop088_rg] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop089_rne] : String {
			name = "..."
			key = true
			help = "..."
		},
		&[isop090_oab] : String {
			name = "..."
			key = true
			help = "..."
		}
	}
}


*struct[SLV38_RegistroGeral38] {
	fields {
		&[isop091_numero] : String {
			name = "Número do RG"
			key = true
			help = "Exemplo: 123456-7"
		},
		-[isop092_orgaoEmissor] : String {
			name = "Órgão emissor do RG"
			key = false
			help = "Informe a sigla do órgão emisor do RG. Por exemplo, se o emissor for a Secretaria de
					Segurança Pública, informe \"SSP\"."
		},
		&[isop093_uf] : List[ListaFederação_LIST30] {
			name = "Unidade da federação onde foi emitido o RG"
			atomic = true
			key = false
			help = "Informe a unidade da federação onde foi emitido o RG."
		},
		-[isop094_dataEmissao] : Date {
			name = "Data de emissão do RG"
			key = false
			help = "A data de emissão do R.G. deve estar no formato dd/mm/aaaa."
		}
	}
}

*struct[SLV39_RegistroNacionalEstrangeiro39] {
	fields {
		&[isop095_numero] : String {
			name = "Número do RNE"
			key = true
			help = "Exemplo: 123456-7"
		},
		-[isop096_orgaoEmissor] : String {
			name = "Órgão emissor do RNE"
			key = false
			help = "Informe a sigla do órgão emisor do RNE. Exemplo: CGPI/DIREX/DPF."
		},
		-[isop097_dataEmissao] : Date {
			name = "Data de emissão do RNE"
			key = false
			help = "A data de emissão do RNE deve estar no formato dd/mm/aaaa."
		}
	}
}

*struct[SLV40_Oab40] {
	fields {
		&[isop098_numero] : String {
			name = "Número de inscrição na OAB"
			key = true
			help = "Exemplo: 999999."
		},
		&[isop099_secional] : List[ListaFederação_LIST31] {
			name = "Unidade da federação da secional onde foi emitida a OAB"
			atomic = true
			key = false
			help = "Informe a unidade da federação onde foi emitida a OAB."
		},
		-[isop100_dataExpedicao] : Date {
			name = "Data de expedição da carteira da OAB"
			key = false
			help = "Informe a data de emissão da carteira da OAB no formato dd/mm/aaaa."
		}
	}
}

*struct[SLV41_Passaporte41] {
	fields {
		&[isop101_numero] : String {
			name = "Número do Passaporte"
			key = true
			help = "Exemplo: AB12345-6"
		},
		&[isop102_paisEmissor] : List[ListaDePaisesCom3Letras_LIST32] {
			name = "País emissor do passaporte"
			atomic = true
			key = false
			default = "06_BRA_STRC"
			help = "Informe a sigla do país emisor do passaporte. Por exemplo, se o país emissor for
					o Brasil, informe \"BRA\"."
		},
		-[isop103_dataValidade] : Date {
			name = "Data de validade do passaporte"
			key = false
			help = "Informe a data até quando o passaporte é válido no formato dd/mm/aaaa."
		},
		-[isop104_dataEmissao] : Date {
			name = "Data de emissão do passaporte"
			key = false
			help = "A data de emissão do passaporte deve estar no formato dd/mm/aaaa."
		},
		-[isop105_localEmissao] : String {
			name = "Local de emissão do passaporte"
			key = false
			help = ""
		},
		if ( [paisEmissor] == "BRA" ) {
			-[isop106_tipo_LIST33] : List("07_Comum_STRC", "Oficial", "Diplomático", "Para estrangeiro", "De emergência") {
				name = "Tipo de passaporte"
				atomic = true
				key = false
				default = "07_Comum_STRC"
				help = ""
			}
		}
	}
}

*struct[SLV42_Logradouro42] {
	fields {
		&[isop107_pais] : List[ListaDePaisesCom3Letras_LIST34] {
			name = "País"
			atomic = true
			key = false
			default = "08_BRA_STRC"
			help = "Informe a sigla do país do logradouro. Por exemplo, \"BRA\"."
		},
		if ([pais] == "BRA") {
			&[isop108_tipo_LIST35] : List("Comercial", "Residencial", "Sede", "Filial", "Sucursal", "Secional") {
				name = "Tipo de endereço"
				atomic = true
				key = false
				help = ""
			},
			&[isop109_principal] : String {
				name = "Endereço principal"
				key = false
				help = "Exemplo: Avenida Magalhães de Castro."
			},
			-[isop110_numero] : String {
				name = "Número do endereço"
				key = false
				help = "Por exemplo, se o endereço é Avenida Magalhães de Castro, nº 286, informe \"286\". Se não houver número, informe \"s/n\"."
			},
			-[isop111_complemento] : String {
				name = "Complemento do endereço"
				key = false
				help = "Exemplo: apartamento 123, sala A, Bloco B."
			},
			-[isop112_bairro] : String {
				name = "Bairro do endereço"
				key = false
				help = "Exemplo: Centro, Bairro Novo"
			},
			&[isop113_codigoPostal] : String where("CEP") {
				name = "CEP"
				key = false
				help = "Informe o CEP do endereço."
			},
			&[isop114_cidade] : String {
				name = "Cidade"
				key = false
				help = "Exemplo: São Paulo."
			},
			&[isop115_uf] : List[ListaFederação_LIST36] {
				name = "Unidade da federação"
				atomic = true
				key = false
				help = "Informe a unidade da federação."
			}
		} elseif ([pais] == "USA") {
			&[isop116_tipo_LIST37] : List("Comercial", "Residencial", "Sede", "Filial", "Sucursal", "Secional") {
				name = "Tipo de endereço"
				atomic = true
				key = false
				help = ""
			},
			&[isop117_principal] : String {
				name = "Primeira linha do endereço"
				key = false
				help = "Exemplo: 123 Avenue of the Americas."
			}
		} else {
			&[isop118_tipo_LIST38] : List("Comercial", "Residencial", "Sede", "Filial", "Sucursal", "Secional") {
				name = "Tipo de endereço"
				atomic = true
				key = false
				help = ""
			},
			&[isop119_principal] : String {
				name = "Primeira linha do endereço"
				key = false
				help = "Exemplo: 123 Avenue of the Americas."
			},
			-[isop120_complemento] : String {
				name = "Segunda linha do endereço"
				key = false
				help = "Exemplo: Building A, 18th floor."
			},
			-[isop121_codigoPostal] : String {
				name = "Código postal"
				key = false
				help = "Informe o código postal do endereço, se houver."
			},
			-[isop122_cidade] : String {
				name = "Cidade"
				key = false
				help = "Exemplo: New York, Paris."
			},
			-[isop123_regiao] : String {
				name = "Unidade da federação, estado, província, território ou outro tipo de subdivisão regional do endereço"
				key = false
				help = "Unidade da federação, estado, província ou outro tipo de subdivisão regional do endereço.
						Exemplo: NY, Province of Quebec, Tokyo Prefecture."
			}
		}
	}
}

*struct[SLV43_InscricaoEstadual43] {
	request = "Por favor informe os dados relativos à inscrição estadual."
	help = "A inscrição estadual é o registro do contribuinte no cadastro do ICMS (imposto sobre operações relativas à circulação
			de mercadorias e sobre prestações de serviços de transporte interestadual, intermunicipal e de comunicação) mantido pela
			Receita Estadual. Com a inscrição, o contribuinte do ICMS passa a ter o registro formal junto à Receita Estadual do estado
			onde está estabelecido."
	fields {
		&[isop124_numero] : String {
			name = "Número da inscrição estadual (IE)"
			key = false
			help = ""
		},
		&[isop125_uf] : List[ListaFederação_LIST39] {
			name = "Unidade da federação da inscrição estadual"
			atomic = true
			key = false
			help = "Por exemplo, se uma empresa tem inscrição estadual em São Paulo, informe \"SP\""
			/* Dá para colocar uma suggestion na UF informada no campo do logradouro?*/
		}
	}
}

*struct[SLV44_InscricaoMunicipal44] {
	request = "Por favor informe os dados relativos à inscrição municipal."
	help = "A inscrição municipal é o número de identificação do contribuinte no Cadastro Tributário Municipal. No que se refere ao
			ISS (imposto sobre serviços de qualquer natureza), a inscrição municipal informa que o contribuinte está inscrito na prefeitura
			como prestador de serviços. É pela inscrição municipal que a prefeitura controla o alvará de localização, funcionamento e
			atividades de prestação de serviços do contribuinte."
	fields {
		&[isop126_numero] : String {
			name = "Número da inscrição estadual (IE)"
			key = false
			help = ""
		},
		&[isop127_uf] : List[ListaFederação_LIST40] {
			name = "Unidade da federação da inscrição municipal"
			atomic = true
			key = false
			default = "09_SP_STRC"
			help = "Por exemplo, se uma empresa tem inscrição estadual em São Paulo, informe \"SP\""
			/* Dá para colocar uma suggestion na UF informada no campo do logradouro?*/
		},
		&[isop128_municipio] : String {
			name = "Município da inscrição municipal"
			key = false
			help = ""
		}
	}
}

*struct[SLV45_AtosConstitutivos45] {
	request = "Por favor informe os dados relativos aos atos constitutivos da pessoa jurídica."
	help = "Os atos constitutivos de uma pessoa jurídica são genericamente chamados de estatutos. Dependendo da natureza da pessoa jurídica,
			seus atos constitutivos poderão ser chamados ainda de estatuto social ou contrato social."
	fields {
		&[isop129_nome_LIST41] : List("Estatuto", "Estatuto social", "Contrato social") {
			name = "Nome dos atos constitutivos das pessoas jurídicas"
			atomic = true
			key = false
			help = "O ato constitutivo de sociedades simples (pura e limitada) é o contrato social. Nos demais casos, o ato constitutivo será
					denominado estatuto (por exemplo, no caso das fundações e associações) ou estatuto social (por exemplo, no caso das sociedades
					por ações e nas sociedades em comandita por ações)."
		},
		&[isop130_orgaoRegistro] : String {
			name = "Órgão de registro dos atos constitutivos da pessoa jurídica."
			key = false
			help = "As entidades sem fins lucrativos, como as fundações e associações, bem como as sociedades simples, são registradas em
					Registro Civil de Pessoas Jurídicas, que é um tipo de cartório que cuida de registrar todos os atos das pessoas jurídicas
					de direito privado sem fins lucrativos, de algumas pessoas jurídicas com fins lucrativos e de empresas e/ou veículos de
					comunicação. Exemplo: 01º Oficial de Registro de Títulos e Documentos e Civil de Pessoa Jurídica da Comarca da Capital –
					São Paulo. Já as entidadades empresárias, como a sociedade empresária limitada e a sociedade por ações, têm seus atos
					constitutivos registrados na Junta Comercial da unidade da federação onde está situada a sede social. Exemplo: Junta
					Comercial do Estado de São Paulo - JUCESP. Exclusivamente no caso das sociedades de advogados, seu contrato social é
					registrado na Secional da Ordem dos Advogados do Brasil com jurisdicão sobre ela."
		},
		&[isop131_numeroRegistro] : String {
			name = "Número de registro da pessoa jurídica"
			key = false
			help = "Número de registro da pessoa jurídica na junta comercial ou cartório onde seus atos constitutivos são registrados. Por
					exemplo, se a pessoa jurídica for registrada em uma junta comercial, o seu número de registro corresponde ao seu
					NIRE (Número de Identificação do Registro de Empresas), composto de 11 dígitos."
		},
		&[isop132_dataRegistro] : Date {
			name = "Data de registro dos atos constitutivos da pessoa jurídica no respectivo órgão de registro"
			key = false
			help = "A informação se refere à data oficial de registro dos atos constitutivos da pessoa jurídica no respectivo
					órgão de registro e deve ser informada no formato dd/mm/aaaa."
		}
	}
}

*struct[SLV46_Advogado46] extends *Sujeito where ( [extwhere10_capacidade] = "Capaz",
				[extwhere11_tipoDePessoa] = "Pessoa natural",
				[extwhere12_personificacao] = "Personificado",
				[extwhere13_profissoes] = "Advogado" )  {
	request = "..."
	help = "..."
}

*struct[SLV47_EscritorioDeAdvocacia47] extends *Sujeito where
					( [extwhere14_personificacao] = "Personificado",
					  [extwhere15_tipoDePessoa] = "Pessoa jurídica",
					  [extwhere16_ramoDireito] = "Direito privado",
					  [extwhere17_tipo] = "Sociedade",
					  [extwhere18_sociedade] = "Sociedade de advogados" ) {
	request = "..."
	help = "..."
}

*branch[SLV48_AliasBranch48] {
	description = "..."
	tags {
		"a11"
	}
	declarations {
		&#inop133_constAlias# : String {
			value = "..."
			help = "..."
		},
		*period[SLV49_AliasPeriod49] {
			description = "..."
			tags {"a11"}
			declarations {
				&<inop134_stcAlias> : *StructName
			}
			operation {
				print {
					[version = "..."],
					[version = "..."]
				}
			}
		},
		*branch[SLV50_AliasBranch50] {
			description = "..."
			tags {"a11"}
			declarations {
				&<inop135_stcAlias> : *StructName
			}
			operations {
				if (<inop135_stcAlias> == "loc01_a") {
					use *period[IUsed031_Alias] where(<where17_inop135_stcAlias>)
				} elseif ( <inop135_stcAlias> == "loc02_a" ) {
					print {
						version = "loc03..."
					}
				} else  {
					print {
						version = "loc04..."
					}
				}
			}
		},
		*topic[SLV51_AliasTopic51] {
			title = "..."
			description = "..."
			tags {"a11"}
			operations {
				use *period[IUsed032_Alias]
			}
		},
		*dependency[SLV52_AliasDependendy52] {
			description = "..."
			tags {"a11"}
			declarations {
				&<inop136_stcAlias> : *StructName
			}
			operation {
				if ( <stcAlias>.isEmpty() ) {
		 			use *period[IUsed033_Alias] where ( <where20_innerElem> = <elem> )
				} elseif ( <stcAlias.n> > 10 ) {
					use *branch[IUsed034_Alias1]
				} else {
					use *branch[IUsed035_Alias2] where ( <where21_innerElem> = <elem> )
				}
			}
		},
		*loop[SLV53_AliasLoop53] {
			separator = "%f1; %s2; %p2; e %l2"
			description = "..."
			tags {"a11"}
			declarations {
				&|inop137_vect| : Vector[*StructName] {
					request = "..."
				}
			}
			operation {
				foreach (<elem> IN |vect|) {
					use *loop[IUsed036_Alias] where ( <where22_innerElem> = <elem> )
				}
			}
		},
		struct[SLV54_StructAlias54] {
			request = "..."
			help = "..."
			fields {
				&[isop138_fieldAlias] : Date {
					name = "fieldLabel"
					key = false
					default = "10_..._STRC_INSIDE_NODE_ONLY"
					help = "..."
				},
				&[isop139_fieldStructAlias] : *StructName
			}
		},
		&<inop140_a> : StructAlias {
			request = "..."
			help = "..."
		}
	}
	operations {
		 use *period[IUsed037_AliasPeriod]
	}
}

*loop[SLV55_AliasLoop55] {
	separator = "%f1; %s2; %p2; e %l2"
	description = "..."
	tags {"a11"}
	declarations {
		&|inop141_vectorAlias| : Vector[StructName] {
			request = "..."
		},
		&|inop142_vectorAlias7| : Vector[Integer] {
			request = "..."
			name = " okoko "
		},
		*struct[SLV56_StructName56] {
			request = "..."
			help = "..."
			fields {
				&|isop143_vectorAlias2| : Vector[String] {
					request = "..."
					name = "a11"
					help = "..."
				}
			}
		},
		-<inop144_v> : StructName
	}
	operation {
		foreach (<elem> IN |vectAlias|) {
			foreach (<loc05_elem2> IN |elem.vectorAlias2|) {
				<attrib02_elem2> = <attrib02_elem2>.ask(),
				print {
					[version = "loc06_assssssssss"],
					[version = "ggggggggggg"]
				},
				print { version = "loc07_..." }
			}
		}
	}
}


*topic[SLV57_AliasTopicWeird57] {
	title = "..."
	description = "..."
	tags {"a11"}
	declarations {
		&|inop145_vectorAlias| : Vector[StructName] {
			request = "..."
		},
		*struct[SLV58_StructName58] {
			request = "..."
			help = "..."
			fields {
				&|isop146_vectorAlias2| : Vector[String] {
					request = "..."
					name = "a11"
					help = "..."
				},
				-[isop147_fieldAlias] : Real {
				}
			}
		},
		*period[SLV59_AliasPeriod59] {
			description = "..."
			tags {"..."}
			declarations {
				&<inop148_stcAlias> : *StructName
			}
			operation {
				print {
					[version = "..."],
					[version = "..."]
				}
			}
		},
		-<inop149_v> : StructName,
		&#inop150_c# : Real {
			value = 0.8
			help = "hhhhhhhhh"
		}
	}
	operations {
		<attrib03_v>.ask(), /* se ask não tiver parâmetros, isto é, ask(), usar pergunta (Question) definida dentre de <v> */
		<attrib04_v>.ask("Uma pergunta específica que redefine a de dentro de <v>"),
		<attrib05_s.fieldASerPerguntado>.ask("Uma pergunta pra aquele field"),
		<attrib06_s.fieldASerPerguntado>.alert(<s.fieldASerAlertado>.mandatory),
		<attrib07_v> = |AliasTopicScope:vectorAlias|.select(1,5),
		<attrib08_v.fieldAlias> = 6 + <v.fieldAlias> * #c#,
		use *period[IUsed038_Per],
		|attrib10_vectorAlias| = |vectorAlias|.lowercase()
	}
}

template[SLVT_DocumentAlias] {
	metainfo {
		/* Padrão de escrita de línguas: https://msdn.microsoft.com/en-us/library/ms533052%28v=vs.85%29.aspx */
		language = "pt_br"
		name = "nome bonito"
		description = "dados da metainfo"
		tags {"a11info", "a1info"}
		declarations {
			*period[SLV60_AliasPeriod60] {
				description = "..."
				tags {"..."}
				operation {
					print {
						[version = "..."],
						[version = "..."]
					}
				}
			},
			*dependency[SLV61_AliasDependendyMTInfo61] {
				description = "..."
				tags {
					"a11"
				}
				declarations {
					&<inop151_a> : externs Integer,
					&<inop152_v> : Integer {
						default = "11_NODE_INSIDE_TEMPLATE"
						request = "..."
					}
				}
				operation {
					if (<a> == 2) {
			 			print {
			 			 	version = "loc08_..."
			 			}
					} elseif ( <a> ~= 34 ) {
						print {version = "loc09_..."},
						<Per:attrib09_v> = <v>,
						<Per:attrib091_v> = <v1>,
						<Per:attrib0911_v> = <v11>
					} else {
						print { version = "loc10_..."},
  						print { version = "loc11_..."}
					}
				}
			},
			*struct[SLV62_StructAlias62] {
				request = "..."
				help = "..."
				fields {
					&[isop153_fieldAlias1] : Date {
						name = "fieldLabel"
						key = false
						default = "12_..._STRC_INSIDE_TEMPLATE"
						help = "..."
					},
					&[isop154_fieldAlias2] : *RegistroGeral,
					if ([fieldAlias2]>=2) {
						&[isop155_fieldAlias3] : *RegistroGeral
					} elseif ([fieldAlias2]==-6) {
						&[isop156_fieldAlias4] : *RegistroGeral
					} else {
						&[isop157_fieldAlias4] : *RegistroGeral
					}
				}
			}
		}
	}
	head {
		title = "..." & printIf(4==2, "Nunca", "Print")
		declarations {
			*loop[SLV63_AliasLoop63] {
				separator = "..."
				description = "..."
				tags {"a11"}
				declarations {
					&|inop158_vectorAlias| : Vector[String] {
						request = "..."
						name = "..."
						help = "..."
					},
					*period[SLV64_AliasPeriod64] {
						description = "..."
						tags {"..."}
						declarations {
							&<inop159_stcAlias> : *StructName
						}
						operation {
							print {
								[version = "..."],
								[version = "..."]
							}
						}
					}
				}
				/* TODO: mexer nisso semanticamente: redefinição de propriedades */
				operation {
					foreach (<elem> IN |vect|) {
				 		use *period[IUsed039_AliasP],
				 		print{[version = "loc12_..."]}
					}
				}
			},
			*period[SLV65_AliasPeriod65] {
				description = "..."
				tags {"a11"}
				declarations {
					&<inop160_varAlias> : String {
						tip = "..."
						help = "..."
						default = "13_..._NODE_INSIDE_TEMPLATE"
						request = "..."
					},
					*branch[SLV66_AliasBranch66] {
					 	description = "..."
					 	tags {"..."}
					 	declarations {
					 		&<inop161_stcAlias> : *StructName,
					 		*struct[SLV67_StructAlias67] {
					 			request = "..."
					 			help = "..."
					 			fields {
					 				&[isop162_fieldAlias] : Real {
					 					name = "fieldLabel"
					 					key = true
					 					default = "14_..._STRC_INSIDE_TEMPLATE"
					 					help = "..."
					 				},
					 				&[isop163_fieldStructAlias] : *StructName
					 			}
					 		}

					 	}
					 	operations {
					 		use *period[IUsed040_Alias]
					 	}
					}
				}
				operation {
					print {
						[version = "..."],
						[version = "..."]
					}
				}
			},
			&<inop164_varLL> : Integer {
				tip = "..."
				help = "..."
				default = "15_..._NODE_INSIDE_TEMPLATE"
				request = "..."
			}
		}
 	}
 	body {
		declarations {
			*topic[SLV68_AliasTopic68] {
				title = "..."
				description = "..."
				tags {"a11", "a121"}
				declarations {
					*branch[SLV69_AliasBranch69] {
						description = "..."
						tags {"a11"}
						declarations {
							&|inop165_vectorAlias| : Vector[Date] {
								request = "..."
								name = "a11"
								help = "..."
							},
							&|inop166_vectorAlias| : Vector[Time] {
								request = "..."
								name = "a11"
								help = "..."
							}
						}
						operations {
							print {
								[version = "..." & <elem>]
							},
							use branch[IUsed041_AliasBranch] where(<where26_elem> = <teste.o>)
						}
					},
					&|inop167_vectorAlias| : Vector[*GStruct] {
						request = "..."
					},
					&<inop168_varAlias> : List[Gender_LIST42] {
						tip = "..."
						help = "..."
						default = "16_..._NODE_INSIDE_TEMPLATE"
						atomic = true
						request = "..."
					}
				}
				operations {
					use *loop[IUsed042_Per]
				}
			}
		}
		operations {
			foreach(<loc13_elem> IN |vect|) {
				print {
					[version = "loc14_..."],
					[version = "..."]
				}
			},
			use *period[IUsed043_Per]
		}
 	}
 	foot {
 		/*date = "1996-05-04"
 		place = here()*/
 		operations {
			 use *branch[IUsed044_AliasBranch]
		}
		declarations {
			*struct[SLV70_StructAlias70] {
				request = "..."
				help = "..."
				fields {
					&[isop169_fieldAlias] : Date {
						name = "fieldLabel"
						key = false
						default = "17_..._STRC_INSIDE_TEMPLATE"
						help = "..."
					},
					&[isop170_fieldAlias] : *RegistroGeral
				}
			},
			*struct[SLV71_StructAlias71] extends *AnotherStruct
							where ( [extwhere19_isop171_fieldAlias].atomic = true,
									[extwhere20_isop171_fieldAlias].mandatory = true,
									[extwhere21_isop171_fieldAlias].help = "help redefinido") {
				request = "essa sobrepõe a de cima."
				help = "..."
				fields {
					&[isop171_fieldAlias_LIST43] : List({"advogado","adv"},{"limpador","lmp"},{"18_boleiro_STRC_INSIDE_TEMPLATE","18_bol"}) {
						name = "fieldAlias \" zms,"
						atomic = true
						key = true
						default = {"18_boleiro_STRC_INSIDE_TEMPLATE","18_bol"}
					}
				}
			},
			*struct[SLV72_StructAlias72] {
				request = "..."
				help = "..."
				fields {
					&[isop172_fieldAlias] : S,
					&[isop173_fieldAlias] : externs *StructAlias,
					&[isop174_fieldAlias] : Time {
						name = "a11"
						key = false
						default = "19_..._STRC_INSIDE_TEMPLATE"
						help = "..."
					},
					if ( [BranchTal:PeriodoTal:fieldAlias.field] > 9 ) {
						&[isop175_fieldAlias] : G
					}
				}
			}
		}
	}
	extra {
		operations {
			attach("filename.png"),
			attach("filename.pdf")
		}
	}
}

*loop[SLV73_AliasLoop73] {
	separator = "%f1; %s2; %p2; e %l2"
	description = "..."
	tags {"..."}
	declarations {
		&|inop176_vectorAlias| : Vector[*StructName] {
			request = "..."
		},
		*dependency[SLV74_AliasDependendy74] {
			description = "..."
			tags {"..."}
			declarations {
				&<inop177_stcAlias> : *StructName
			}
			operation {
				if ( <stcAlias>.isEmpty() ) {
		 			use *loop[IUsed045_Alias] where ( <where28_innerElem> = <elem>, #where27_constAlias# = "Azul" )
				} elseif ( <stcAlias.n> > 10 ) {
					use *branch[IUsed046_Alias1]
				} else {
					use *branch[IUsed047_Alias2]
				}
			}
		}
	}
	operation {
		foreach (<elem> IN |vect|) {
			use *loop[IUsed048_Alias] where ( <where29_innerElem> = <elem> )
		}
	}
}

*struct[SLV75_StructAliasTESTE75] {
	request = "..."
	help = "..."
	fields {
		&[isop178_fieldAlias] : String {
			name = "fieldLabel"
			key = true
			default = "20_..._STRC"
			help = "..."
		}
	}
}

*dependency[SLV76_AliasDependendy76] {
	description = "..."
	tags {"..."}
	declarations {
		&<inop179_stcAlias> : *StructName where ([cccc] = 22, [cccc.b] = true, [cccc.s] = "true", [cccc.o] = [cccc.a], [cccc].mandatory = "&"),
		&<isop180_Alias> : String {
			tip = "..."
			help = "..."
			default = "21_..._NODE_ONLY"
			request = "..."
		}
	}
	operation {
		if ( <stcAlias>.isEmpty() ) {
 			use *period[IUsed049_Alias] where ( <where30_innerElem> = <elem> )
		} elseif ( <stcAlias.n> > 10 ) {
			use *branch[IUsed050_Alias1]
		} else {
			if ( <inop179_stcAlias> == "loc15_aa" ) {
				use *branch[IUsed051_Alias2]
			} elseif ( <inop179_stcAlias> == "loc16_aa" ) {
				use *loop[IUsed052_Alias2],
				use *loop[IUsed053_Alias2] where (<where33_inop179_stcAlias>)
			} else {
				if ( <inop179_stcAlias> == "loc17_aa" ) {
					if ( <inop179_stcAlias> == "loc18_aa" ) {
						if ( <inop179_stcAlias> == "loc19_aa" ) {
							if ( <inop179_stcAlias> == "loc20_aa" ) {
								use *loop[IUsed054_Alias2] where (<where39_inop179_stcAlias>),
								use *loop[IUsed055_Alias2] where (<where40_inop179_stcAlias>),
								print {
									[version = "loc21" & <where41_inop179_stcAlias.name>]
								},
								<a> = (<b>-<c>)*(<g>&<h.numero>) - isEmpty(<d>)
							}
						}
					}
				}
			}
		}
	}
}

*list[SLV77_ListaFederação_LIST44] {
	fields = {"Estado","Sigla"}
	options = ({"Acre","AC"}, {"Alagoas","AL"})
	type = "String"
}